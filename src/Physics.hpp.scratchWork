// Based on https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331

#include <glm/glm.hpp>

struct Vec2 : glm::vec2 {
  float Length() {
    return this->length();
  }
  float LengthSquared() {
    return x*x + y*y;
  }
};

// "An Axis Aligned Bounding Box (AABB) is a box that has its four axes aligned with the coordinate system in which it resides. This means it is a box that cannot rotate, and is always squared off at 90 degrees (usually aligned with the screen). In general it is referred to as a "bounding box" because AABBs are used to bound other more complex shapes."
// "The AABB of a complex shape can be used as a simple test to see if more complex shapes inside the AABBs can possibly be intersecting. However in the case of most games the AABB is used as a fundamental shape, and does not actually bound anything else. The structure of your AABB is important. There are a few different ways to represent an AABB, however this is my favorite:"
struct AABB
{
  Vec2 min;
  Vec2 max;
};

// "Here's a quick test taken from Real-Time Collision Detection [ https://realtimecollisiondetection.net/ ] by Christer Ericson, which makes use of the SAT [Separating Axis Theorem]:"
bool AABBvsAABB( AABB a, AABB b )
{
  // Exit with no intersection if found separated along an axis
  if(a.max.x < b.min.x or a.min.x > b.max.x) return false
  if(a.max.y < b.min.y or a.min.y > b.max.y) return false
 
  // No separating axis found, therefor there is at least one overlapping axis
  return true
}

// "A circle is represented by a radius and point. Here is what your circle structure ought to look like:"
struct Circle
{
  float radius;
  union { // Union for convenience: can access Circle.position.x or just Circle.x
    Vec2 position;
    struct {
      float x;
      float y;
    };
  };
};
#if 0 // COMPILE_TIME_TESTING
#define member_size(type, member) sizeof(((type *)0)->member) // https://stackoverflow.com/questions/3553296/sizeof-single-struct-member-in-c

#define strcat_(x, y) x ## y
#define strcat(x, y) strcat_(x, y)
#define PRINT_VALUE(x) \
    template <int> \
    struct strcat(strcat(value_of_, x), _is); \
    static_assert(strcat(strcat(value_of_, x), _is)<x>::x, "");


#line 4242
constexpr int PI_INT = __LINE__;  /*set the value*/

//PRINT_VALUE(PI_INT) /*print it*/

constexpr int TEST = offsetof(Circle, x);
PRINT_VALUE(TEST) // 4! wow. it works. https://stackoverflow.com/questions/28852574/how-to-print-result-of-a-compile-time-calculation-in-c

constexpr int TEST2 = offsetof(Vec2, x);
PRINT_VALUE(TEST2)
constexpr int TEST3 = offsetof(Circle, x) - (offsetof(Circle, radius) + member_size(Circle, radius));
PRINT_VALUE(TEST3)
#endif
static_assert(offsetof(Circle, x) - (offsetof(Circle, radius) + member_size(Circle, radius)) == offsetof(Vec2, x), "Location of the `x` member of `Circle` struct should be the same as the actual location in `Circle` struct but when accessed from the Vec2 `position`");
static_assert(offsetof(Circle, y) - offsetof(Circle, x) == offsetof(Vec2, y), "Same as above, but for y");

// "Testing for whether or not two circles intersect is very simple: take the radii of the two circles and add them together, then check to see if this sum is greater than the distance between the two circles."
#define SQUARED(x) x*x
float Distance( Vec2 a, Vec2 b )
{
  return sqrt( SQUARED(a.x - b.x) + SQUARED(a.y - b.y) );
}

bool CirclevsCircleUnoptimized( Circle a, Circle b )
{
  float r = a.radius + b.radius;
  return r < Distance( a.position, b.position );
}

// "An important optimization to make here is get rid of any need to use the square root operator:"
bool CirclevsCircleOptimized( Circle a, Circle b )
{
  float r = a.radius + b.radius;
  r *= r;
  return r < SQUARED(a.x + b.x) + SQUARED(a.y + b.y);
}


struct Object {
  Vec2 velocity;

  float inv_mass; // This is 1 / the mass. We store this for optimization purposes.
  float mass() const { return 1 / inv_mass; }
  void setMass(float mass) {
    // {"
    // If we go ahead and use the code we have so far, objects will run into each other and bounce off. This is great, although what happens if one of the objects has infinite mass? Well we need a good way to represent infinite mass within our simulation.
    // 
    // I suggest using zero as infinite mass - although if we try to compute inverse mass of an object with zero we will have a division by zero. The workaround to this is to do the following when computing inverse mass:
    // "}
    if(mass == 0)
      inv_mass = 0;
    else
      inv_mass = 1 / mass;
  }
  
  float restitution;
};

// For when two objects collide but they will separate next frame anyway: "Two objects collide, but velocity will separate them next frame. Do not resolve this type of collision."
// "If objects are moving away from one another we want to do nothing. This will prevent objects that shouldn't actually be considered colliding from resolving away from one another. This is important for creating a simulation that follows human intuition on what should happen during object interaction."
void ResolveCollision( Object A, Object B )
{
  // Calculate relative velocity
  Vec2 rv = B.velocity - A.velocity;
 
  // Calculate relative velocity in terms of the normal direction
  float velAlongNormal = DotProduct( rv, normal );
 
  // Do not resolve if velocities are separating
  if(velAlongNormal > 0)
    return;
 
  // Calculate restitution
  float e = min( A.restitution, B.restitution);
 
  // Calculate impulse scalar
  float j = -(1 + e) * velAlongNormal;
  j /= A.inv_mass + B.inv_mass;
 
  // Apply impulse
  Vec2 impulse = j * normal;
  A.velocity -= A.inv_mass * impulse;
  B.velocity += B.inv_mass * impulse;
}

void ResolveCollision_other(Object A, Object B) {
  // ? what does he mean:
// {"
// Many physics engines do not actually store raw mass. Physics engines often times store inverse mass and inverse mass alone. It just so happens that most math involving mass is in the form of 1/mass.
// The last thing to note is that we intelligently distribute our impulse scalar j over the two objects. We want small objects to bounce off of big objects with a large portion of j, and the big objects to have their velocities modified by a very small portion of j.
// 
// In order to do this you could do:
// 
// float mass_sum = A.mass + B.mass
// float ratio = A.mass / mass_sum
// A.velocity -= ratio * impulse
//  
// ratio = B.mass / mass_sum
// B.velocity += ratio * impulse
//
// It is important to realize that the above code is equivalent to the ResolveCollision() sample function from before. Like stated before, inverse masses are quite useful in a physics engine.
// 
// "}
  
  float mass_sum = A.mass + B.mass;
  float ratio = A.mass / mass_sum;
  A.velocity -= ratio * impulse;
 
  ratio = B.mass / mass_sum;
  B.velocity += ratio * impulse;
}

// {"
// The problem of sinking objects arises when something starts sinking into another object due to gravity. Perhaps something with low restitution hits a wall with infinite mass and begins to sink.
// 
// This sinking is due to floating point errors. During each floating point calculation a small floating point error is introduced due to hardware. (For more information, Google [Floating point error IEEE754].) Over time this error accumulates in positional error, causing objects to sink into one another.
// 
// In order to correct this error it must be accounted for. To correct this positional error I will show you a method called linear projection. Linear projection reduces the penetration of two objects by a small percentage, and this is performed after the impulse is applied. Positional correction is very simple: move each object along the collision normal n by a percentage of the penetration depth:
// "}
void PositionalCorrection( Object A, Object B )
{
  const float percent = 0.2; // usually 20% to 80%
    // "Note that we scale the penetrationDepth by the total mass of the system. This will give a positional correction proportional to how much mass we are dealing with. Small objects push away faster than heavier objects."
  Vec2 correction = penetrationDepth / (A.inv_mass + B.inv_mass)) * percent * n;
  A.position -= A.inv_mass * correction;
  B.position += B.inv_mass * correction;
}

// "There is a slight problem with this implementation: if we are always resolving our positional error then objects will jitter back and forth while they rest upon one another. In order to prevent this some slack must be given. We only perform positional correction if the penetration is above some arbitrary threshold, referred to as "slop":"
void PositionalCorrectionWithSlop( Object A, Object B )
{
  const float percent = 0.2; // usually 20% to 80%
  const float slop = 0.01; // usually 0.01 to 0.1
  // "This allows objects to penetrate ever so slightly without the position correction kicking in."
  Vec2 correction = max( penetration - k_slop, 0.0f ) / (A.inv_mass + B.inv_mass)) * percent * n;
  A.position -= A.inv_mass * correction;
  B.position += B.inv_mass * correction;
}

// "The last topic to cover in this article is simple manifold generation. A manifold in mathematical terms is something along the lines of "a collection of points that represents an area in space". However, when I refer to the term manifold I am referring to a small object that contains information about a collision between two objects."
struct Manifold
{
  Object *A;
  Object *B;
  // "During collision detection, both penetration and the collision normal should be computed. In order to find this info the original collision detection algorithms from the top of this article must be extended."
  float penetration;
  Vec2 normal;
};

bool CirclevsCircle( Manifold *m )
{
  // Setup a couple pointers to each object
  Object *A = m->A;
  Object *B = m->B;
 
  // Vector from A to B
  Vec2 n = B->pos - A->pos;
 
  float r = A->radius + B->radius;
  r *= r;
 
  if(n.LengthSquared( ) > r)
    return false;
 
  // Circles have collided, now compute manifold
  float d = n.Length( ); // perform actual sqrt
 
  // If distance between circles is not zero
  if(d != 0);
  {
    // Distance is difference between radius and distance
    m->penetration = r - d;
 
    // Utilize our d since we performed sqrt on it already within Length( )
    // Points from A to B, and is a unit vector
    c->normal = t / d;
    return true;
  }
 
  // Circles are on same position
  else
  {
    // Choose random (but consistent) values
    c->penetration = A->radius;
    c->normal = Vec( 1, 0 );
    return true;
  }
}

bool AABBvsAABB( Manifold *m )
{
  // Setup a couple pointers to each object
  Object *A = m->A;
  Object *B = m->B;
  
  // Vector from A to B
  Vec2 n = B->pos - A->pos;
  
  AABB abox = A->aabb;
  AABB bbox = B->aabb;
  
  // Calculate half extents along x axis for each object
  float a_extent = (abox.max.x - abox.min.x) / 2;
  float b_extent = (bbox.max.x - bbox.min.x) / 2;
  
  // Calculate overlap on x axis
  float x_overlap = a_extent + b_extent - abs( n.x );
  
  // SAT test on x axis
  if(x_overlap > 0)
  {
    // Calculate half extents along x axis for each object
    float a_extent = (abox.max.y - abox.min.y) / 2;
    float b_extent = (bbox.max.y - bbox.min.y) / 2;
  
    // Calculate overlap on y axis
    float y_overlap = a_extent + b_extent - abs( n.y );
  
    // SAT test on y axis
    if(y_overlap > 0)
    {
      // Find out which axis is axis of least penetration
      if(x_overlap > y_overlap)
      {
        // Point towards B knowing that n points from A to B
        if(n.x < 0)
          m->normal = Vec2( -1, 0 );
        else
          m->normal = Vec2( 0, 0 );
	m->penetration = x_overlap;
        return true;
      }
      else
      {
        // Point toward B knowing that n points from A to B
        if(n.y < 0)
          m->normal = Vec2( 0, -1 );
        else
          m->normal = Vec2( 0, 1 );
        m->penetration = y_overlap;
        return true;
      }
    }
  }
}

bool AABBvsCircle( Manifold *m )
{
  // Setup a couple pointers to each object
  Object *A = m->A;
  Object *B = m->B;
 
  // Vector from A to B
  Vec2 n = B->pos - A->pos;
 
  // Closest point on A to center of B
  Vec2 closest = n;
 
  // Calculate half extents along each axis
  float x_extent = (A->aabb.max.x - A->aabb.min.x) / 2;
  float y_extent = (A->aabb.max.y - A->aabb.min.y) / 2;
 
  // Clamp point to edges of the AABB
  closest.x = Clamp( -x_extent, x_extent, closest.x );
  closest.y = Clamp( -y_extent, y_extent, closest.y );
 
  bool inside = false;
 
  // Circle is inside the AABB, so we need to clamp the circle's center
  // to the closest edge
  if(n == closest)
  {
    inside = true;
 
    // Find closest axis
    if(abs( n.x ) > abs( n.y ))
    {
      // Clamp to closest extent
      if(closest.x > 0)
        closest.x = x_extent;
      else
        closest.x = -x_extent;
    }
 
    // y axis is shorter
    else
    {
      // Clamp to closest extent
      if(closest.y > 0)
        closest.y = y_extent;
      else
        closest.y = -y_extent;
    }
  }
 
  Vec2 normal = n - closest;
  real d = normal.LengthSquared( );
  real r = B->radius;
 
  // Early out of the radius is shorter than distance to closest point and
  // Circle not inside the AABB
  if(d > r * r && !inside)
    return false;
 
  // Avoided sqrt until we needed
  d = sqrt( d );
 
  // Collision normal needs to be flipped to point outside if circle was
  // inside the AABB
  if(inside)
  {
    m->normal = -n;
    m->penetration = r - d;
  }
  else
  {
    m->normal = n;
    m->penetration = r - d;
  }
 
  return true;
}


// Part 2 //

// Game loop
void gameLoop() {
  const float fps = 100;
  const float dt = 1 / fps;
  float accumulator = 0;
 
  // In units of seconds
  float frameStart = GetCurrentTime( );
 
  // main loop
  while(true) {
    const float currentTime = GetCurrentTime( );
  
    // Store the time elapsed since the last frame began
    accumulator += currentTime - frameStart( );
 
    // Record the starting of this frame
    frameStart = currentTime;
 
    while(accumulator > dt) {
      UpdatePhysics( dt );
      accumulator -= dt;
    }
 
    RenderGame( );
  }
}

// Game loop that doesn't grind to a halt if physics take too long to compute, just slows down time if frames take too long to compute:
void gameLoop() {
  const float fps = 100;
  const float dt = 1 / fps;
  float accumulator = 0;
 
  // In units of seconds
  float frameStart = GetCurrentTime( );
 
  // main loop
  while(true) {
    const float currentTime = GetCurrentTime( );
  
    // Store the time elapsed since the last frame began
    accumulator += currentTime - frameStart( );
 
    // Record the starting of this frame
    frameStart = currentTime;

    // Avoid spiral of death and clamp dt, thus clamping
    // how many times the UpdatePhysics can be called in
    // a single game loop.
    if(accumulator > 0.2f)
      accumulator = 0.2f;
 
    while(accumulator > dt) {
      UpdatePhysics( dt );
      accumulator -= dt;
    }
 
    RenderGame( );
  }
}

// Game loop with linear interpolation as well, to fix issue where time steps can suddenly be greater.
// {"
// Here, all objects within the game can be drawn at variable moments between discrete physics timesteps. This will gracefully handle all error and remainder time accumulation. This is actually rendering ever so slightly behind what the physics has currently solved for, but when watching the game run all motion is smoothed out perfectly by the interpolation.
// 
// The player will never know that the rendering is ever so slightly behind the physics, because the player will only know what they see, and what they'll see is perfectly smooth transitions from one frame to another.
// "}
void RenderGame( float alpha );
void gameLoop() {
  const float fps = 100;
  const float dt = 1 / fps;
  float accumulator = 0;
 
  // In units of seconds
  float frameStart = GetCurrentTime( );
 
  // main loop
  while(true) {
    const float currentTime = GetCurrentTime( );
  
    // Store the time elapsed since the last frame began
    accumulator += currentTime - frameStart( );
 
    // Record the starting of this frame
    frameStart = currentTime;

    // Avoid spiral of death and clamp dt, thus clamping
    // how many times the UpdatePhysics can be called in
    // a single game loop.
    if(accumulator > 0.2f)
      accumulator = 0.2f;
 
    while(accumulator > dt) {
      UpdatePhysics( dt );
      accumulator -= dt;
    }
 
    const float alpha = accumulator / dt;
 
    RenderGame( alpha );
  }
}

void RenderGame( float alpha ) {
  for shape : game.shapes {
    // calculate an interpolated transform for rendering
    Transform i = shape.previous * alpha + shape.current * (1.0f - alpha);
    shape.previous = shape.current;
    shape.Render( i );
  }
}

struct MassData
{
  float mass;
  float inv_mass;
 
  // For rotations (not covered in this article)
  float inertia;
  float inverse_inertia;
};

struct Material
{
  float density;
  float restitution;
};

struct body
{
  Shape *shape;
  Transform tx;
  Material material;
  MassData mass_data;
  Vec2 velocity;
  Vec2 force; // "This value starts at zero at the beginning of each physics update. Other influences in the physics engine (such as gravity) will add Vec2 vectors into this force data member. Just before integration all of this force will be used to calculate acceleration of the body, and be used during integration. After integration this force data member is zeroed out."
  real gravityScale;
};

struct Pair
{
  body *A;
  body *B;
};

// "A broad phase should collect a bunch of possible collisions and store them all in Pair structures. These pairs can then be passed on to another portion of the engine (the narrow phase), and then resolved."


struct BroadPhase {
  std::vector<Pair> pairs;
  std::vector<body> bodies;
  
  void GeneratePairs( void );
};
bool SortPairs( Pair lhs, Pair rhs )
{
  if(lhs.A < rhs.A)
    return true;
 
  if(lhs.A == rhs.A)
    return lhs.B < rhs.B;
 
  return false;
}
// Example O(n^2) broad phase:
// Generates the pair list.
// All previous pairs are cleared when this function is called.
void BroadPhase::GeneratePairs( void )
{
  pairs.clear( )
 
  // Cache space for AABBs to be used in computation
  // of each shape's bounding box
  AABB A_aabb
  AABB B_aabb
 
  for(i = bodies.begin( ); i != bodies.end( ); i = i->next)
  {
    for(j = bodies.begin( ); j != bodies.end( ); j = j->next)
    {
      Body *A = &i->GetData( )
      Body *B = &j->GetData( )
 
      // Skip check with self
      if(A == B)
        continue
 
      A->ComputeAABB( &A_aabb )
      B->ComputeAABB( &B_aabb )
 
      if(AABBtoAABB( A_aabb, B_aabb ))
        pairs.push_back( A, B )
    }
  }

  // Need to remove duplicates //
  
  // Sort pairs to expose duplicates
  sort( pairs, pairs.end( ), SortPairs );
 
  // Queue manifolds for solving
  {
    int i = 0;
    while(i < pairs.size( ))
      {
	Pair *pair = pairs.begin( ) + i;
	uniquePairs.push_front( pair );
 
	++i;
 
	// Skip duplicate pairs by iterating i until we find a unique pair
	while(i < pairs.size( ))
	  {
	    Pair *potential_dup = pairs + i;
	    if(pair->A != potential_dup->B || pair->B != potential_dup->A)
	      break;
	    ++i;
	  }
      }
  }
}
